from web3 import Web3
import timeit
from unittest.mock import Mock
from forta_agent import create_transaction_event, get_json_rpc_url
from .agent import provide_handle_transaction, initialize
from .blocklisted_check import handle_transaction as blocklisted_check


mock_check_etherscan_blocklist = Mock()

handle_transaction = provide_handle_transaction(mock_check_etherscan_blocklist)
mock_tx_event = create_transaction_event({})

real_w3 = Web3(Web3.HTTPProvider(get_json_rpc_url()))

class TestExploiterAddressTxBot:

    def test_exploiter_address_tx_perf_test(self):
        global real_w3
        initialize()

        global real_w3
        tx = real_w3.eth.get_transaction(
            '0xe0bf600d62e99f2f7b0bd6ce27a7167b8c04bd5a06727155c0334ca5c39dfd6c')

        global exploiter_address_tx_event
        exploiter_address_tx_event = create_transaction_event({
            'transaction': {
                'hash': '0xe0bf600d62e99f2f7b0bd6ce27a7167b8c04bd5a06727155c0334ca5c39dfd6c',
                'to': tx.to,
                'from': tx['from'],
                'value': tx.value
            },
            'block': {
                'number': tx.blockNumber
            },
            'receipt': {
                'logs': []
            }
        })

        tx = real_w3.eth.get_transaction(
            '0xa371f8a8b54bad37899c73234533520f614fe97a3acc89e9a3933a2a50a72cc9')

        global normal_tx_event
        normal_tx_event = create_transaction_event({
            'transaction': {
                'hash': '0xa371f8a8b54bad37899c73234533520f614fe97a3acc89e9a3933a2a50a72cc9',
                'to': tx.to,
                'from': tx['from'],
                'value': tx.value
            },
            'block': {
                'number': tx.blockNumber
            },
            'receipt': {
                'logs': []
            }
        })
        

        # Chain: Blocktime, Number of Tx -> Avg processing time in ms target
        # Ethereum: 12s, 150 -> 80ms
        # BSC: 3s, 70 -> 43ms
        # Polygon: 2s, 50 -> 40ms
        # Avalanche: 2s, 5 -> 400ms
        # Arbitrum: 1s, 5 -> 200ms
        # Optimism: 24s, 150 -> 160ms
        # Fantom: 1s, 5 -> 200ms

        # local testing reveals an avg processing time of 230, which results in the following sharding config:
        # Ethereum: 12s, 150 -> 80ms - 3
        # BSC: 3s, 70 -> 43ms - 6
        # Polygon: 2s, 50 -> 40ms - 6
        # Avalanche: 2s, 5 -> 400ms - 1
        # Arbitrum: 1s, 5 -> 200ms - 2
        # Optimism: 24s, 150 -> 160ms - 2
        # Fantom: 1s, 5 -> 200ms - 2

        # we're assuming 0,5% of tx will contain a transaction that involves a known exploiter address

        processing_runs = 10
        processing_time_exploiter_tx_avg_ms = timeit.timeit(
            'blocklisted_check(exploiter_address_tx_event)', number=processing_runs, globals=globals()) * 1000 / processing_runs

        processing_time_normal_tx_avg_ms = timeit.timeit(
            'blocklisted_check(normal_tx_event)', number=processing_runs, globals=globals()) * 1000 / processing_runs
        
        print((processing_time_exploiter_tx_avg_ms * 0.005 + processing_time_normal_tx_avg_ms * 0.995) / 2)
        
        assert (processing_time_exploiter_tx_avg_ms * 0.005 + processing_time_normal_tx_avg_ms * 0.995) / \
            2 < 230, "processing time should be less than 230ms."
        
    def test_returns_findings(self):
        mock_finding = {'some': 'finding'}
        mock_check_etherscan_blocklist.return_value = [mock_finding]

        findings = handle_transaction(mock_tx_event)

        assert len(findings) == 1
        for finding in findings:
            assert finding == mock_finding

        mock_check_etherscan_blocklist.assert_called_once_with(mock_tx_event)
